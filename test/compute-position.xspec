<?xml version="1.0" encoding="UTF-8"?>
<x:description xmlns:local="urn:x-xspec:compiler:xproc:compile:compute-position:local"
    xmlns:my="x-urn:my-xproc-namespace" xmlns:p="http://www.w3.org/ns/xproc"
    xmlns:x="http://www.jenitennison.com/xslt/xspec" xmlns:xs="http://www.w3.org/2001/XMLSchema"
    stylesheet="../src/compiler/compile-xproc-tests.xsl">

    <x:param name="initial-document" href="xproc/cases/two-inputs-no-option-one-output.xspec"
        select="/"/>

    <x:scenario label="Test local:gather-steps mode">
        <x:scenario label="in p:library without imports">
            <x:context mode="local:gather-steps" select="/">
                <p:library>
                    <p:declare-step type="my:step1">
                        <p:input port="aux1"/>
                        <p:input port="source" primary="true"/>
                        <p:input port="aux2" use-when="true()"/>
                        <p:output port="result"/>
                        <p:option name="my:opt"/>
                        <p:declare-step type="my:substep">
                            <p:input port="source"/>
                            <p:output port="result"/>
                            <p:identity/>
                        </p:declare-step>
                        <p:identity/>
                    </p:declare-step>
                    <p:declare-step type="my:step2">
                        <p:input port="source" sequence="true"/>
                        <p:output port="result"/>
                        <p:identity/>
                    </p:declare-step>
                </p:library>
            </x:context>
            <x:expect select="/">
                <x:label>p:library containing flat list of simplified child steps, each with
                    URI-qualified step type</x:label>
                <p:library>
                    <p:declare-step type="Q{{x-urn:my-xproc-namespace}}step1">
                        <p:input port="aux1"/>
                        <p:input port="source"/>
                        <p:input port="aux2" use-when="true()"/>
                    </p:declare-step>
                    <p:declare-step type="Q{{x-urn:my-xproc-namespace}}step2">
                        <p:input port="source"/>
                    </p:declare-step>
                </p:library>
            </x:expect>
            <x:expect label="Substeps are not included."
                test="empty($x:result/descendant::p:declare-step[ends-with(@type,'}substep')])"/>
        </x:scenario>
        <x:scenario label="in p:declare-step without imports">
            <x:context mode="local:gather-steps" select="/">
                <p:declare-step type="my:pipeline">
                    <p:input port="aux1"/>
                    <p:input port="source" primary="true"/>
                    <p:input port="aux2"/>
                    <p:output port="result"/>
                    <p:option name="my:opt"/>
                    <p:declare-step type="my:substep">
                        <p:input port="source" sequence="true"/>
                        <p:output port="result"/>
                        <p:identity/>
                    </p:declare-step>
                    <p:identity/>
                </p:declare-step>
            </x:context>
            <x:expect select="/">
                <x:label>p:declare-step as a simplified step with URI-qualified step type</x:label>
                <p:declare-step type="Q{{x-urn:my-xproc-namespace}}pipeline">
                    <p:input port="aux1"/>
                    <p:input port="source"/>
                    <p:input port="aux2"/>
                </p:declare-step>
            </x:expect>
            <x:expect label="Substeps are not included."
                test="empty($x:result/descendant::p:declare-step[ends-with(@type,'substep')])"/>
        </x:scenario>
        <x:scenario label="with import (circular, in fact)">
            <x:context mode="local:gather-steps" href="xproc/cases/circular-import1.xpl"/>
            <x:expect select="/">
                <x:label>All the steps in the library and its imports, recursively, with p:library
                    parents retained for imports</x:label>
                <p:library>
                    <p:declare-step type="Q{{x-urn:test:xproc:steplibrary}}step1">
                        <p:input port="source"/>
                    </p:declare-step>
                    <p:library>
                        <p:declare-step type="Q{{x-urn:test:xproc:steplibrary}}step2">
                            <p:input port="source"/>
                        </p:declare-step>
                    </p:library>
                </p:library>
            </x:expect>
        </x:scenario>
    </x:scenario>

    <x:scenario label="Test x:input-position function">
        <x:scenario label="in2">
            <x:call function="x:input-position">
                <x:param
                    select="$initial-document/x:description/x:scenario[1]/x:scenario[1]//x:input[@name='in2']"
                />
            </x:call>
            <x:expect label="is in position 2" select="2"/>
        </x:scenario>
        <x:scenario label="in1">
            <x:call function="x:input-position">
                <x:param
                    select="$initial-document/x:description/x:scenario[1]/x:scenario[1]//x:input[@name='in1']"
                />
            </x:call>
            <x:expect label="is in position 1" select="1"/>
        </x:scenario>
        <x:scenario label="Unknown step name" catch="yes">
            <x:call function="x:input-position">
                <x:param href="xproc/cases/error-and-warning-cases.xspec"
                    select="exactly-one(//x:scenario[@label eq 'Unknown step'])/x:call/x:input"/>
            </x:call>
            <x:expect label="returns error" result-type="map(*)"
                test="$x:result?err?value => string()" as="xs:string" select="normalize-space(.)"
                >Cannot find input port 'source' in step
                Q{x-urn:test:xproc:steplibrary}nonexistent</x:expect>
        </x:scenario>
        <x:scenario label="Unknown port name" catch="yes">
            <x:call function="x:input-position">
                <x:param href="xproc/cases/error-and-warning-cases.xspec"
                    select="exactly-one(//x:scenario[@label eq 'Unknown input'])/x:call/x:input"/>
            </x:call>
            <x:expect label="returns error" result-type="map(*)"
                test="$x:result?err?value => string()" as="xs:string" select="normalize-space(.)"
                >Cannot find input port 'nonexistent' in step
                Q{x-urn:test:xproc:steplibrary}one-input-no-option-one-output</x:expect>
        </x:scenario>
        <x:scenario label="If an input port declaration has use-when" catch="no">
            <x:call function="x:input-position">
                <x:param href="xproc/cases/error-and-warning-cases.xspec"
                    select="exactly-one(//x:scenario[@label eq 'Step with use-when on p:input'])/x:call/x:input[@name='source']"/>
            </x:call>
            <x:expect label="the calling sequence assumes use-when evaluates to true" select="2"/>
        </x:scenario>
    </x:scenario>

    <x:scenario label="Test local:UQName-of-step function">
        <x:scenario label="on step declaration">
            <x:scenario label="with colon in step type">
                <x:call function="local:UQName-of-step">
                    <x:param href="xproc/cases/library.xpl"
                        select="/p:library/p:declare-step[@type='s:step-with-substep']/@type"/>
                </x:call>
                <x:expect label="returns URI-qualified name"
                    select="'Q{x-urn:test:xproc:steplibrary}step-with-substep'"/>
            </x:scenario>
            <x:scenario label="without colon in step type">
                <x:call function="local:UQName-of-step">
                    <x:param select="/*/@type">
                        <p:declare-step type="Q{{x-urn:test:xproc:steplibrary}}step"/>
                    </x:param>
                </x:call>
                <x:expect label="returns string value of @type"
                    select="'Q{x-urn:test:xproc:steplibrary}step'"/>
            </x:scenario>
        </x:scenario>
        <x:scenario label="on XSpec call">
            <x:scenario label="with colon in step type">
                <x:call function="local:UQName-of-step">
                    <x:param href="xproc/cases/no-input-no-option-one-output.xspec"
                        select="//x:scenario[@label='No input, no option, one output']/x:call/@step"/>
                </x:call>
                <x:expect label="returns URI-qualified name"
                    select="'Q{x-urn:test:xproc:steplibrary}no-input-no-option-one-output'"/>
            </x:scenario>
            <x:scenario label="without colon in step type">
                <x:call function="local:UQName-of-step">
                    <x:param href="xproc/cases/no-input-no-option-one-output.xspec"
                        select="//x:scenario[@label='Q{} notation in x:call/@step']/x:call/@step"/>
                </x:call>
                <x:expect label="returns string value of @step"
                    select="'Q{x-urn:test:xproc:steplibrary}no-input-no-option-one-output'"/>
            </x:scenario>
        </x:scenario>
    </x:scenario>
    <x:scenario label="Test local:step-type function">
        <x:call function="local:step-type">
            <x:param href="xproc/cases/one-input-no-option-one-output.xspec"
                select="//x:scenario[@label='One input, no option, one output']/x:call/x:input"/>
        </x:call>
        <x:expect label="returns URI-qualified name of step"
            select="'Q{x-urn:test:xproc:steplibrary}one-input-no-option-one-output'"/>
    </x:scenario>

</x:description>
